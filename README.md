# music-symbols-detector
 Распознавание нотных элементов с помощью OpenCV

---

## Цель на текущий момент

1. Подготовить изображения для каждого из 35 элементов:
   - минимум 30 позитивных (с нужным элементом)
   - минимум 100 негативных (без этого элемента)
2. Разметить координаты элемента в позитивных изображениях
3. Собрать все данные по структуре

---

## Автоматическая нарезка нотных символов

Для быстрой подготовки датасета используйте скрипт `part_cut.py`.

### Как пользоваться

1. Положите изображения с нотами в папку `input/` (поддерживаются .png, .jpg, .jpeg, .bmp).
2. Запустите скрипт:
   ```sh
   python part_cut.py --input input --output output/parts --prefix myprefix_
   ```
   - `--input` — папка с исходными изображениями (по умолчанию `input`)
   - `--output` — папка для сохранения фрагментов (по умолчанию `output/parts`)
   - `--prefix` — префикс для имён файлов (опционально)

3. После выполнения:
   - В папке `output/parts/` появятся подпапки по классам (`diez`, `dot`, `note_head`, `pause_quarter`, и т.д.)
   - В каждой подпапке будут отдельные изображения фрагментов
   - В файле `output/parts/annotations.txt` будут аннотации в формате:
     ```
     [класс]/[имя_фрагмента] x y w h
     ```

### Как работает сортировка

Скрипт автоматически определяет класс символа по размеру и пропорциям (см. словарь `SYMBOL_CLASSES` в `part_cut.py`).
Если символ не подходит ни под одно правило — он попадает в папку `unknown`.

---

## Структура проекта

```md
recognize/
├── positive_images/
│   └── [элемент]/ # например: clef_g, diez, pause_whole
├── negative_images/
│   └── [элемент]/ # такие же названия, как у positive
├── annotations/
│   └── [элемент].txt # аннотации с координатами
├── samples/ # временные файлы (создаются автоматически)
├── classifier/ # сюда будет сохраняться результат обучения (например, diez.xml)
└── results/ # по желанию: распознанные изображения, xml и т.п.

input/ # папка для исходных изображений для автонарезки
output/parts/ # результат автонарезки по классам и аннотации
```

---

## Формат аннотаций

Файл: `annotations/[элемент].txt`

Каждая строка — путь к изображению и координаты нужного элемента:
- positive_images/diez/001.jpg 34 15 12 12
- positive_images/diez/002.jpg 20 18 14 14


Формат:
[путь_к_изображению] [x] [y] [width] [height]

---

## Задачи команды

### Нарезчики изображений:
- На каждого назначено 4–5 элементов
- Вырезать позитивные изображения и сохранить в `positive_images/[элемент]/`
- Собирать негативные изображения в `negative_images/[элемент]/`
- Именование файлов: `001.jpg`, `002.jpg`, ...

### Техническая команда:
- Проверка структуры и качества изображений
- Создание `positives.txt` / `negatives.txt`
- Генерация `.vec` с помощью `opencv_createsamples`
- Обучение модели через `opencv_traincascade`

---

## Рекомендации

- Использовать изображения чёткие, с нотным станом (цвет: чёрно-белый)
- Размер позитивного изображения: элемент должен быть по центру, от 30×30 до 50×50 пикселей
- Никаких лишних элементов (текст, другие ноты и т.д.)
- Внутри одной папки не должно быть одинаковых названий файлов

---

## Пример названий элементов (некоторые)

- clef_g
- clef_f
- pause_quarter
- note_whole
- sharp
- flat
- dot
- time_4_4
- ending_1

Всего — 35 папок и столько же аннотаций.

---

## Что делать при ошибке

- Проверить структуру папок вручную
- Убедиться, что изображения `.jpg`, а не `.png`
- Проверить, что аннотации содержат **путь и 4 координаты**

---


