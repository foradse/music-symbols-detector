# music-symbols-detector
 Распознавание нотных элементов с помощью OpenCV

---

## Быстрый гайд: как быстро нарезать и разметить свои скриншоты

### 1. Подготовь изображения
- Помести свои скриншоты или фотографии нот в папку `input/` в корне проекта.
- Поддерживаются форматы: `.png`, `.jpg`, `.jpeg`, `.bmp`.
- Можно кидать как отдельные символы, так и целые строки/такты — программа сама нарежет фрагменты.

### 2. Запусти автонарезку
- Открой терминал в корне проекта.
- Выполни команду:
  ```sh
  python part_cut.py --input input --output output/parts --prefix myprefix_
  ```
  - `--input` — папка с исходными изображениями (по умолчанию `input`)
  - `--output` — папка для сохранения фрагментов (по умолчанию `output/parts`)
  - `--prefix` — префикс для имён файлов (опционально, удобно если много разных сессий)

### 3. Проверь результат
- После выполнения появятся папки:
  - `output/parts/positive/[класс]/` — вырезанные фрагменты по классам (`diez`, `flat`, `dot`, ...)
  - `output/parts/unknown/unknown/` — нераспознанные символы (их можно просмотреть и вручную раскидать по нужным классам)
  - `output/parts/debug/` — изображения с цветными рамками и подписями классов (очень удобно для быстрой визуальной проверки)
  - `output/parts/annotations.txt` — аннотации для всех фрагментов в формате `[класс]/[имя_фрагмента] x y w h`

### 4. Что делать дальше
- Используй папки `positive/[класс]/` для обучения моделей или ручной разметки.
- Проверь debug-изображения — они помогут быстро увидеть, что и откуда вырезалось.
- Если что-то попало в `unknown` — можно вручную переместить в нужный класс.
- Аннотации пригодятся для последующей автоматической разметки или обучения детекторов.

### Советы
- Для лучшего результата используй чёткие изображения, без лишних помех.
- Если нужно нарезать только определённый класс — кидай в `input` только такие изображения.
- Если что-то не распознаётся — можно скорректировать правила в `SYMBOL_CLASSES` в `part_cut.py`.

---

## Установка и запуск (для новых пользователей)

### 1. Установи Python
- Скачай и установи Python 3.8+ с официального сайта: https://www.python.org/downloads/
- При установке обязательно поставь галочку "Add Python to PATH".

### 2. Установи pip (если не установился вместе с Python)
- Обычно pip уже есть. Проверить:
  ```sh
  python -m pip --version
  ```
- Если не установлен — следуй инструкции: https://pip.pypa.io/en/stable/installation/

### 3. Установи необходимые библиотеки
- Открой терминал в папке проекта и выполни:
  ```sh
  pip install opencv-python numpy
  ```
- Если используешь Windows и возникнут ошибки с установкой, попробуй:
  ```sh
  python -m pip install --upgrade pip
  pip install opencv-python numpy
  ```

### 4. Запусти автонарезку
- Всё готово! Теперь можешь пользоваться быстрым гайдом выше.
- Пример команды:
  ```sh
  python part_cut.py --input input --output output/parts --prefix myprefix_
  ```

---

## Цель на текущий момент

1. Подготовить изображения для каждого из 35 элементов:
   - минимум 30 позитивных (с нужным элементом)
   - минимум 100 негативных (без этого элемента)
2. Разметить координаты элемента в позитивных изображениях
3. Собрать все данные по структуре

---

## Автоматическая нарезка нотных символов

Для быстрой подготовки датасета используйте скрипт `part_cut.py`.

### Как пользоваться

1. Положите изображения с нотами в папку `input/` (поддерживаются .png, .jpg, .jpeg, .bmp).
2. Запустите скрипт:
   ```sh
   python part_cut.py --input input --output output/parts --prefix myprefix_
   ```
   - `--input` — папка с исходными изображениями (по умолчанию `input`)
   - `--output` — папка для сохранения фрагментов (по умолчанию `output/parts`)
   - `--prefix` — префикс для имён файлов (опционально)

3. После выполнения:
   - В папке `output/parts/` появятся подпапки по классам (`diez`, `dot`, `note_head`, `pause_quarter`, и т.д.)
   - В каждой подпапке будут отдельные изображения фрагментов
   - В файле `output/parts/annotations.txt` будут аннотации в формате:
     ```
     [класс]/[имя_фрагмента] x y w h
     ```

### Как работает сортировка

Скрипт автоматически определяет класс символа по размеру и пропорциям (см. словарь `SYMBOL_CLASSES` в `part_cut.py`).
Если символ не подходит ни под одно правило — он попадает в папку `unknown`.

---

## Структура проекта

```md
recognize/
├── positive_images/
│   └── [элемент]/ # например: clef_g, diez, pause_whole
├── negative_images/
│   └── [элемент]/ # такие же названия, как у positive
├── annotations/
│   └── [элемент].txt # аннотации с координатами
├── samples/ # временные файлы (создаются автоматически)
├── classifier/ # сюда будет сохраняться результат обучения (например, diez.xml)
└── results/ # по желанию: распознанные изображения, xml и т.п.

input/ # папка для исходных изображений для автонарезки
output/parts/ # результат автонарезки по классам и аннотации
```

---

## Формат аннотаций

Файл: `annotations/[элемент].txt`

Каждая строка — путь к изображению и координаты нужного элемента:
- positive_images/diez/001.jpg 34 15 12 12
- positive_images/diez/002.jpg 20 18 14 14


Формат:
[путь_к_изображению] [x] [y] [width] [height]

---

## Задачи команды

### Нарезчики изображений:
- На каждого назначено 4–5 элементов
- Вырезать позитивные изображения и сохранить в `positive_images/[элемент]/`
- Собирать негативные изображения в `negative_images/[элемент]/`
- Именование файлов: `001.jpg`, `002.jpg`, ...

### Техническая команда:
- Проверка структуры и качества изображений
- Создание `positives.txt` / `negatives.txt`
- Генерация `.vec` с помощью `opencv_createsamples`
- Обучение модели через `opencv_traincascade`

---

## Рекомендации

- Использовать изображения чёткие, с нотным станом (цвет: чёрно-белый)
- Размер позитивного изображения: элемент должен быть по центру, от 30×30 до 50×50 пикселей
- Никаких лишних элементов (текст, другие ноты и т.д.)
- Внутри одной папки не должно быть одинаковых названий файлов

---

## Пример названий элементов (некоторые)

- clef_g
- clef_f
- pause_quarter
- note_whole
- sharp
- flat
- dot
- time_4_4
- ending_1

Всего — 35 папок и столько же аннотаций.

---

## Что делать при ошибке

- Проверить структуру папок вручную
- Убедиться, что изображения `.jpg`, а не `.png`
- Проверить, что аннотации содержат **путь и 4 координаты**

---


