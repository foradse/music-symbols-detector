# Группа 1: Классификатор музыкальных символов

## Задача
Обучить нейронную сеть, которая по изображению определяет тип музыкального символа: нота, пауза, ключ или другой символ.

## Команда
2 человека

## Что нужно сделать

### 1. Подготовка данных
- Изучить структуру датасета в папке `dataset/`
- Понять, какие классы символов у нас есть
- Проверить качество изображений в `train/` и `val/`

### 2. Архитектура модели (`model.py`)
- Создать CNN архитектуру для классификации
- Рекомендуемые слои:
  - Сверточные слои (Conv2d)
  - MaxPooling
  - Dropout для регуляризации
  - Полносвязные слои
- Размер входа: 64x64 пикселей (grayscale)
- Выход: количество классов символов

### 3. Обучение модели (`train.py`)
- Настроить DataLoader для загрузки данных
- Выбрать функцию потерь (CrossEntropyLoss)
- Настроить оптимизатор (Adam)
- Добавить валидацию во время обучения
- Сохранять лучшую модель в `models/classifier_cnn.pth`

### 4. Предсказание (`predict.py`)
- Создать функцию для загрузки обученной модели
- Реализовать предсказание для одного изображения
- Добавить порог уверенности
- Возвращать класс и уверенность

## Технологии
- **PyTorch** - основной фреймворк
- **torchvision** - для трансформаций изображений
- **numpy** - для работы с массивами
- **PIL** - для загрузки изображений

## Структура файлов
```
classifier/
├── model.py          # Архитектура нейронной сети
├── train.py          # Скрипт обучения
├── predict.py        # Функции предсказания
└── README.md         # Этот файл
```

## Как запустить

### Обучение модели:
```bash
cd classifier
python train.py
```

### Тестирование предсказания:
```python
from predict import predict_symbol

result = predict_symbol(
    image_path="path/to/symbol.png",
    model_path="../models/classifier_cnn.pth",
    class_names=['clef_g', 'sharp', 'flat', ...]
)
print(f"Класс: {result['class']}, Уверенность: {result['confidence']}")
```

## Классы символов
- **Ключи:** clef_g, clef_f, clef_c, clef_g8
- **Знаки альтерации:** sharp, flat, natural, double_sharp
- **Ноты:** note_whole, note_head_half, note_head_quarter
- **Паузы:** pause_whole_half, pause_quarter, pause_eighth, pause_sixteenth
- **Хвосты:** tail_eighth, tail_sixteenth, tail_eighth_group, tail_sixteenth_group
- **Размеры:** time_2_2, time_2_4, time_3_4, time_4_4, time_common
- **Другие:** dot, ending_1, ending_2, repeat

## Цели
1. **Точность на валидации:** > 90%
2. **Время предсказания:** < 100ms на символ
3. **Размер модели:** < 50MB

## Критерии готовности
- [ ] Модель обучается без ошибок
- [ ] Точность на валидации > 85%
- [ ] Модель сохраняется в `models/classifier_cnn.pth`
- [ ] Функция `predict_symbol()` работает корректно
- [ ] Код документирован и читаем

## Связь с другими группами
- **Вход:** изображения символов от группы 3 (symbol_detector)
- **Выход:** предсказания классов для группы 4 (xml_exporter)
- **Данные:** датасет из `dataset/` (создается `build_dataset.py`)

## Советы
1. Начните с простой архитектуры, потом усложняйте
2. Используйте аугментацию данных (группа 5 поможет)
3. Следите за переобучением
4. Тестируйте на разных типах символов
5. Сохраняйте промежуточные результаты

## Если застряли
1. Проверьте формат данных в `dataset/`
2. Убедитесь, что все зависимости установлены
3. Начните с малого датасета для отладки
4. Обратитесь к Адлану за помощью 